import connectK.CKPlayer;
import connectK.BoardModel;

import java.awt.Point;


public class FrAInkenstienAI extends CKPlayer {

	public FrAInkenstienAI(byte player, BoardModel state) 
	{
		super(player, state);
		teamName = "FrAInkenstein";
	}

	@Override
	public Point getMove(BoardModel state) 
	{
		return getMove(state, 5000);	
	}

	@Override
	public Point getMove(BoardModel state, int deadline) 
	{
		long stop_time = System.currentTimeMillis() + deadline;
		int depth_limit = 1;
		
		FrAInkensteinNode tree = new FrAInkensteinNode(state);
		FrAInkensteinNode best_node = tree;
		
		while (System.currentTimeMillis() < stop_time)
		{
			expandNode(tree, true, depth_limit, stop_time);
			if (System.currentTimeMillis() < stop_time)
			{
				minmaxSearch(tree, depth_limit, stop_time);
			}
			else
			{
				break;
			}
			
			if (System.currentTimeMillis() < stop_time && depth_limit < state.spacesLeft)
			{
				best_node = tree.getChildren()[tree.getBest()];
			}
			else
			{
				break;
			}
			depth_limit++;
		}
		return findMove(state, best_node.getState());
	}
	public void minmaxSearch(FrAInkensteinNode node, int depth, long stopTime)
	{
		 // Assign heuristic values to children of node recursively
	}
	
	public int max(BoardModel state)
	{
		return 0;
	}
	
	public int min(BoardModel state)
	{
		return 0;
	}
	
	
	public Point findMove(BoardModel state1, BoardModel state2)
	{
		for (int col = 0; col < state1.getWidth(); col++)
		{
			for (int row = 0; row < state1.getHeight(); row++)
			{
				if (state1.getSpace(row, col) != state2.getSpace(row, col))
				{
					return new Point(row, col);
				}
			}
		}
		return null;
	}
	
	public void expandNode(FrAInkensteinNode node, boolean maximize, int depthLimit, long stopTime)
	{
		if (depthLimit == 0)
		{
			if (maximize)
			{
				// Add children to the node left to right.
				// Set next state to opponent's turn and recur to calculate deeper
			}
		}
	}
}